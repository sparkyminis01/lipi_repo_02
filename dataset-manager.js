try{console.info('[DatasetManager] Script loaded and initializing...');const DatasetManager=(function(){'use strict';const DB_NAME='lipikit_datasets';const STORE_NAME='datasets';const DB_VERSION=1;function assertConfig(){if(typeof AppConfig==='undefined'||!AppConfig.config||!AppConfig.config.data){throw new Error('AppConfig.config.data is required. Make sure config.js is loaded before dataset-manager.js');}
if(typeof AppSettings==='undefined'||!AppSettings.datasets){throw new Error('AppSettings.datasets is required. Make sure appsettings.js is loaded before dataset-manager.js');}}
function ensureEndsWithJson(name){if(!name)return name;return name.match(/\.json$/i)?name:`${name}.json`;}
function resolveFileName(fileName){if(!fileName)return fileName;return/_master$/i.test(fileName)?`${fileName}.min.json`:ensureEndsWithJson(fileName);}
function buildLocalVersionPath(overridePath){if(overridePath)return ensureEndsWithJson(overridePath);const cfg=AppConfig.config.data;const folder=(cfg.localDataFolder||'').replace(/\/?$/,'/');const file=ensureEndsWithJson(cfg.versionFileName||'version');return`${folder}${file}`;}
function buildLocalDatasetPath(fileName){const cfg=AppConfig.config.data;const folder=(cfg.localDataFolder||'').replace(/\/?$/,'/');return`${folder}${resolveFileName(fileName)}`;}
function buildRemoteDatasetUrl(fileName){const cfg=AppConfig.config.data;const baseUrl=(cfg.dataUrl||'').replace(/\/?$/,'/');const folder=(cfg.remoteDataFolder||'').replace(/\/?$/,'/');return`${baseUrl}${folder}${resolveFileName(fileName)}`;}
function getVersionStorageKey(){const cfg=AppConfig.config.data;const prefix=cfg.datasetPrefix||'';const baseKey=cfg.versionStorageKey||'version_json';return`${prefix}${baseKey}`;}
function getDatasetStorageKey(fileName){const cfg=AppConfig.config.data;const prefix=cfg.datasetPrefix||'';return`${prefix}${fileName}`;}
async function fetchJson(url){console.info(`[DatasetManager] Fetching JSON from ${url}`);const res=await fetch(url,{cache:'no-store'});if(!res.ok)throw new Error(`Fetch failed (${res.status} ${res.statusText}) for ${url}`);return await res.json();}
async function openDB(){return new Promise((resolve,reject)=>{const request=indexedDB.open(DB_NAME,DB_VERSION);request.onerror=()=>reject(new Error(`IndexedDB open failed: ${request.error}`));request.onsuccess=()=>resolve(request.result);request.onupgradeneeded=(event)=>{const db=event.target.result;if(!db.objectStoreNames.contains(STORE_NAME)){db.createObjectStore(STORE_NAME);}};});}
async function idbPut(key,value){const db=await openDB();return new Promise((resolve,reject)=>{const tx=db.transaction(STORE_NAME,'readwrite');const store=tx.objectStore(STORE_NAME);const request=store.put(value,key);request.onerror=()=>reject(new Error(`IndexedDB put failed for ${key}: ${request.error}`));request.onsuccess=()=>resolve();tx.oncomplete=()=>db.close();});}
async function idbGet(key){const db=await openDB();return new Promise((resolve,reject)=>{const tx=db.transaction(STORE_NAME,'readonly');const store=tx.objectStore(STORE_NAME);const request=store.get(key);request.onerror=()=>reject(new Error(`IndexedDB get failed for ${key}: ${request.error}`));request.onsuccess=()=>{resolve(request.result);db.close();};});}
async function idbDelete(key){const db=await openDB();return new Promise((resolve,reject)=>{const tx=db.transaction(STORE_NAME,'readwrite');const store=tx.objectStore(STORE_NAME);const request=store.delete(key);request.onerror=()=>reject(new Error(`IndexedDB delete failed for ${key}: ${request.error}`));request.onsuccess=()=>{resolve();db.close();};});}
async function idbGetAllKeys(){const db=await openDB();return new Promise((resolve,reject)=>{const tx=db.transaction(STORE_NAME,'readonly');const store=tx.objectStore(STORE_NAME);const request=store.getAllKeys();request.onerror=()=>reject(new Error(`IndexedDB getAllKeys failed: ${request.error}`));request.onsuccess=()=>{resolve(request.result);db.close();};});}
function compareVersions(v1,v2){if(!v1)return-1;if(!v2)return 1;const toParts=(v)=>v.split('.').map(n=>parseInt(n,10));const[a1,b1,c1]=toParts(v1);const[a2,b2,c2]=toParts(v2);if(a1!==a2)return a1-a2;if(b1!==b2)return b1-b2;return c1-c2;}
async function initializeFromLocal(options={}){try{if(typeof AppConfig==='undefined'||!AppConfig.config||!AppConfig.config.data){throw new Error('AppConfig.config.data is required. Make sure config.js is loaded before calling initializeFromLocal');}
const storageKey=getVersionStorageKey();if(!options.force){const existing=localStorage.getItem(storageKey);if(existing){try{const parsed=JSON.parse(existing);console.debug('[DatasetManager] initializeFromLocal: runtime version already present; skipping (use force:true to overwrite).');return{ok:true,from:'existing',data:parsed,path:'LocalStorage'};}catch(e){console.warn('[DatasetManager] initializeFromLocal: existing runtime version parsing failed, will overwrite.',e);}}}
const localPath=buildLocalVersionPath(options.localVersionPath);console.info(`[DatasetManager] initializeFromLocal: loading local version file from ${localPath}`);const versionJson=await fetchJson(localPath);if(!versionJson||typeof versionJson!=='object'||!versionJson.datasets){console.warn('[DatasetManager] initializeFromLocal: loaded version file does not have a "datasets" object. Still saving runtime copy for safety.');}
try{localStorage.setItem(storageKey,JSON.stringify(versionJson));}catch(e){throw new Error(`Failed to persist runtime version in LocalStorage under "${storageKey}": ${e.message || e}`);}
console.info('[DatasetManager] initializeFromLocal: saved runtime version to LocalStorage under',storageKey);return{ok:true,from:'local',data:versionJson,path:localPath};}catch(err){console.error('[DatasetManager] initializeFromLocal failed:',err);return{ok:false,error:err.message||String(err)};}}
async function load_dataset_with_check(datasetKey,options={}){try{assertConfig();const datasetConfig=AppSettings.datasets[datasetKey];if(!datasetConfig){throw new Error(`Dataset key "${datasetKey}" not found in AppSettings.datasets`);}
const fileName=datasetConfig;const storageKey=getVersionStorageKey();const datasetStorageKey=getDatasetStorageKey(fileName);const versionJsonStr=localStorage.getItem(storageKey);if(!versionJsonStr){throw new Error('Runtime version.json not found in LocalStorage. Run initializeFromLocal first.');}
const versionJson=JSON.parse(versionJsonStr);const datasetInfo=versionJson.datasets[fileName];if(!datasetInfo||!datasetInfo.url){throw new Error(`No URL defined for dataset ${fileName} in version.json`);}
const localUrl=datasetInfo.url;console.info(`[DatasetManager] load_dataset_with_check: attempting to load ${datasetKey} (file: ${fileName})`);const cachedData=await idbGet(datasetStorageKey);if(!options.skipRemote){try{const remoteVersionJson=await fetchJson(buildRemoteDatasetUrl(AppConfig.config.data.versionFileName));const remoteDatasetInfo=remoteVersionJson.datasets[fileName];if(remoteDatasetInfo){if(datasetInfo.version&&compareVersions(remoteDatasetInfo.version,datasetInfo.version)>0){const remoteUrl=buildRemoteDatasetUrl(fileName);const remoteData=await fetchJson(remoteUrl);console.info(`[DatasetManager] load_dataset_with_check: updated ${datasetKey} from remote ${remoteUrl}`);await idbPut(datasetStorageKey,remoteData);versionJson.datasets[fileName]={...datasetInfo,version:remoteDatasetInfo.version,lastFetchedAt:new Date().toISOString()};localStorage.setItem(storageKey,JSON.stringify(versionJson));return{ok:true,from:'remote',data:remoteData,path:remoteUrl};}}}catch(err){console.warn(`[DatasetManager] load_dataset_with_check: remote version check failed for ${datasetKey}: ${err.message}`);}}
if(!options.force&&cachedData){console.info(`[DatasetManager] load_dataset_with_check: serving ${datasetKey} from cache (v${datasetInfo.version})`);return{ok:true,from:'cache',data:cachedData,path:'IndexedDB'};}
if(!options.skipRemote){try{const remoteUrl=buildRemoteDatasetUrl(fileName);const remoteVersionJson=await fetchJson(buildRemoteDatasetUrl(AppConfig.config.data.versionFileName));const remoteDatasetInfo=remoteVersionJson.datasets[fileName];if(!remoteDatasetInfo){console.warn(`[DatasetManager] load_dataset_with_check: no entry for ${fileName} in remote version.json, skipping remote fetch.`);}else{if(datasetInfo.version&&compareVersions(remoteDatasetInfo.version,datasetInfo.version)<=0){console.info(`[DatasetManager] load_dataset_with_check: cached ${datasetKey} already up-to-date (local v${datasetInfo.version} vs remote v${remoteDatasetInfo.version}). Skipping remote fetch.`);return{ok:true,from:'cache',data:cachedData,path:'IndexedDB'};}
const remoteUrl=buildRemoteDatasetUrl(fileName);const remoteData=await fetchJson(remoteUrl);console.info(`[DatasetManager] load_dataset_with_check: fetched ${datasetKey} from remote ${remoteUrl}`);await idbPut(datasetStorageKey,remoteData);versionJson.datasets[fileName]={...datasetInfo,version:remoteDatasetInfo.version,lastFetchedAt:new Date().toISOString()};localStorage.setItem(storageKey,JSON.stringify(versionJson));console.info(`[DatasetManager] load_dataset_with_check: updated version.json for ${datasetKey} in LocalStorage`);return{ok:true,from:'remote',data:remoteData,path:remoteUrl};}}catch(err){console.warn(`[DatasetManager] load_dataset_with_check: remote fetch failed for ${datasetKey} at ${buildRemoteDatasetUrl(fileName)}: ${err.message}`);}}
const localPath=buildLocalDatasetPath(fileName);console.info(`[DatasetManager] load_dataset_with_check: loading bundled local ${localPath}`);const localData=await fetchJson(localPath);await idbPut(datasetStorageKey,localData);versionJson.datasets[fileName]={...datasetInfo,lastFetchedAt:new Date().toISOString()};localStorage.setItem(storageKey,JSON.stringify(versionJson));console.info(`[DatasetManager] load_dataset_with_check: updated version.json for ${datasetKey} in LocalStorage`);return{ok:true,from:'local',data:localData,path:localUrl};}catch(err){console.error(`[DatasetManager] load_dataset_with_check failed for ${datasetKey}:`,err);return{ok:false,error:err.message||String(err)};}}
async function getDataset(datasetKey){try{assertConfig();const datasetConfig=AppSettings.datasets[datasetKey];if(!datasetConfig){throw new Error(`Dataset key "${datasetKey}" not found in AppSettings.datasets`);}
const datasetStorageKey=getDatasetStorageKey(datasetConfig);const data=await idbGet(datasetStorageKey);if(!data){throw new Error(`Dataset ${datasetKey} not found in IndexedDB`);}
console.info(`[DatasetManager] getDataset: retrieved ${datasetKey} from IndexedDB (key: ${datasetStorageKey})`);return{ok:true,data,path:'IndexedDB'};}catch(err){console.error(`[DatasetManager] getDataset failed for ${datasetKey}:`,err);return{ok:false,error:err.message||String(err)};}}
async function getAvailableDatasets(){try{assertConfig();const keys=await idbGetAllKeys();const prefix=AppConfig.config.data.datasetPrefix||'';const datasets=Object.entries(AppSettings.datasets).filter(([_,fileName])=>keys.includes(`${prefix}${fileName}`)).map(([datasetKey])=>datasetKey);console.info('[DatasetManager] getAvailableDatasets:',datasets);return{ok:true,data:datasets};}catch(err){console.error('[DatasetManager] getAvailableDatasets failed:',err);return{ok:false,error:err.message||String(err)};}}
async function clearDataset(datasetKey){try{assertConfig();const datasetConfig=AppSettings.datasets[datasetKey];if(!datasetConfig){throw new Error(`Dataset key "${datasetKey}" not found in AppSettings.datasets`);}
const datasetStorageKey=getDatasetStorageKey(datasetConfig);await idbDelete(datasetStorageKey);console.info(`[DatasetManager] clearDataset: deleted ${datasetKey} from IndexedDB (key: ${datasetStorageKey})`);return{ok:true};}catch(err){console.error(`[DatasetManager] clearDataset failed for ${datasetKey}:`,err);return{ok:false,error:err.message||String(err)};}}
async function clearAllDatasets(options={}){try{assertConfig();const db=await openDB();return new Promise((resolve,reject)=>{const tx=db.transaction(STORE_NAME,'readwrite');const store=tx.objectStore(STORE_NAME);const request=store.clear();request.onerror=()=>reject(new Error(`IndexedDB clear failed: ${request.error}`));request.onsuccess=async()=>{console.info('[DatasetManager] clearAllDatasets: cleared all datasets from IndexedDB');if(options.resetVersion){await initializeFromLocal({force:true});console.info('[DatasetManager] clearAllDatasets: reinitialized version.json');}
resolve({ok:true});db.close();};});}catch(err){console.error('[DatasetManager] clearAllDatasets failed:',err);return{ok:false,error:err.message||String(err)};}}
return{initializeFromLocal,load_dataset_with_check,getDataset,getAvailableDatasets,clearDataset,clearAllDatasets,_internal:{buildLocalVersionPath,getVersionStorageKey,ensureEndsWithJson,getDatasetStorageKey,resolveFileName,buildLocalDatasetPath,buildRemoteDatasetUrl}};})();console.info('[DatasetManager] Initialization complete, DatasetManager defined.');window.DatasetManager=DatasetManager;}catch(err){console.error('[DatasetManager] Initialization failed:',err);throw err;}